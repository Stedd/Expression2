@name aMaze
@inputs Move1Step Start:vector Aimvector:vector
@outputs Gyrodbg:angle Ndist Sdist Edist Wdist
@persist  Ptrig Step:vector VirtPos:vector NDist SDist EDist WDist CtCDist DronePos:vector Dmass Drone:entity A:angle V:vector Scanner:ranger [ScanDir,DirN, DirS, DirE, DirW]:vector
@trigger 
@model models/mechanics/wheels/wheel_rounded_36.mdl
runOnTick(1)

if (first())
{
    #Center Center Distance
    CtCDist = 95.353
    
    ##Define directions
    DirN = vec(-1,0,0)
    DirS = vec(1,0,0)
    DirE = vec(0,1,0)
    DirW = vec(0,-1,0)
    
    #Init Some values
    VirtPos = Start
    Step = vec(0,0,0)
    Ptrig = 0
}

#######Functions#######

function void keepPos(TargetVector:vector)
{
    #Mass
    Drone = entity()
    Drone:setMass(4000)
    Dmass = Drone:mass()
    #Angle 
    A = -ang(Drone:angles():pitch(),Drone:angles():yaw(),Drone:angles():roll())
    Drone:applyAngForce((A + $A*15)*10*Dmass)
    #Applyforce
    V = (TargetVector+vec(0,0,30)-DronePos)
    Drone:applyForce((V + $V*6)*10*Dmass)
}

function number scanner(ScanDir:vector)
{
    Scanner = rangerOffset(2000,DronePos,ScanDir)
    return Scanner:distance()
}

function void wallScan()
{
    #N
    Ndist = scanner(DirN)
    #S
    Sdist = scanner(DirS)
    #E
    Edist = scanner(DirE)
    #W
    Wdist = scanner(DirW)
}

function vector step(StepDir:vector, StepDist)
{
    Step = StepDir*CtCDist*round((StepDist-47.58)/CtCDist)
    return Step
}

function void decider()
{
   if(Move1Step && Ptrig==0)
    {
        Step = step(DirN,Ndist)
        Ptrig = 1  
    }
    else
    {
     Step = vec(0,0,0)   
    }

    #step(DirN,Ndist)
    #step(DirS,Sdist)
    #step(DirE,Edist)
    #step(DirW,Wdist)

}

function void mover()
{
     VirtPos += Step
}

function void saver()
{
    
}


#######Main Loop#######

DronePos = Drone:pos()+entity():massCenterL()
#print(entity():massCenterL())
keepPos(VirtPos)
wallScan()
decider()
mover()

#saver()




